import os
import json
from pymongo import MongoClient

import oqs
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

# -------------------- CONFIG: MongoDB Atlas --------------------
MONGO_URI = (
    "mongodb+srv://Rocky27:sp191612@iomt.x5hkb.mongodb.net/"
    "?retryWrites=true&w=majority&appName=iomt"
)
client = MongoClient(MONGO_URI)
db = client["IoMT_Project"]        # Same DB name as sensor
collection = db["sensor_data"]     # Same collection name as sensor

# -------------------- FILES: Doctor's and Sensor's Keys --------------------
DOCTOR_KYBER_SECRET_KEY_FILE = "doctor_kyber_secret_key.bin"
SENSOR_DILITHIUM_PUBLIC_KEY_FILE = "sensor_dilithium_pub.bin"

# -------------------- Load Doctor's Kyber Secret Key --------------------
def load_doctor_kyber_secret_key():
    """
    This file is generated by 'generate_doctor_keys.py'.
    Only the doctor has access to the secret key.
    """
    with open(DOCTOR_KYBER_SECRET_KEY_FILE, "rb") as f:
        return f.read()

# -------------------- Load Sensor's Dilithium Public Key --------------------
def load_sensor_dilithium_public_key():
    """
    The sensor side generated this key pair.
    We only need the sensor's public key to verify signatures.
    """
    with open(SENSOR_DILITHIUM_PUBLIC_KEY_FILE, "rb") as f:
        return f.read()

# -------------------- Verify & Decrypt --------------------
def verify_and_decrypt(document, doc_secret_key, sensor_pub_key):
    """
    1) Extract the combined_ciphertext & signature from the document.
    2) Verify the Dilithium signature using the sensor's public key.
    3) Decapsulate (Kyber) to recover the shared AES key.
    4) Decrypt the AES ciphertext to get the sensor data.
    """
    combined_ciphertext = document["combined_ciphertext"]
    signature_hex = document["signature"]
    signature = bytes.fromhex(signature_hex)

    # Convert combined_ciphertext to bytes for signature verification
    to_verify = json.dumps(combined_ciphertext).encode()

    # 1) Verify signature with Dilithium
    with oqs.Signature("Dilithium3") as verifier:
        valid = verifier.verify(to_verify, signature, sensor_pub_key)
    if not valid:
        print("Signature verification failed for document:", document["_id"])
        return None

    # 2) Decapsulate (Kyber) to recover the AES key
    kem_ciphertext = bytes.fromhex(combined_ciphertext["kem_ciphertext"])
    with oqs.KeyEncapsulation("Kyber512", secret_key=doc_secret_key) as kem:
        shared_secret_doctor = kem.decap_secret(kem_ciphertext)

    # 3) Use the shared secret to decrypt AES
    aes_key = shared_secret_doctor[:32]
    iv = bytes.fromhex(combined_ciphertext["iv"])
    aes_ciphertext = bytes.fromhex(combined_ciphertext["aes_ciphertext"])

    cipher = AES.new(aes_key, AES.MODE_CBC, iv)
    decrypted_padded = cipher.decrypt(aes_ciphertext)
    try:
        decrypted_data = unpad(decrypted_padded, AES.block_size)
    except ValueError:
        print("AES unpad error - possible corruption in document:", document["_id"])
        return None

    # 4) Return the decrypted JSON as a Python dict
    return json.loads(decrypted_data.decode())

# -------------------- Anomaly Detection --------------------
def check_anomaly(sensor_data):
    """
    Basic threshold-based anomaly detection.
    Returns a list of anomalies found, or an empty list if everything is normal.
    """
    anomalies = []
    bp = sensor_data.get("blood_pressure", {})
    systolic = bp.get("systolic", 0)
    diastolic = bp.get("diastolic", 0)

    if systolic > 140 or diastolic > 90:
        anomalies.append("High blood pressure")
    elif systolic < 90 or diastolic < 60:
        anomalies.append("Low blood pressure")

    heart_rate = sensor_data.get("heart_rate", 0)
    if heart_rate > 120:
        anomalies.append("High heart rate")
    elif heart_rate < 50:
        anomalies.append("Low heart rate")

    temperature = sensor_data.get("temperature", 0)
    if temperature > 38.5:
        anomalies.append("Fever (high temperature)")
    elif temperature < 36.0:
        anomalies.append("Low body temperature")

    glucose = sensor_data.get("glucose", 0)
    if glucose > 180:
        anomalies.append("High glucose level")
    elif glucose < 70:
        anomalies.append("Low glucose level")

    return anomalies

# -------------------- Main Flow --------------------
def main():
    # 1) Load keys
    doc_secret_key = load_doctor_kyber_secret_key()
    sensor_pub_key = load_sensor_dilithium_public_key()

    print("=== Doctor's App Started ===")
    print("Loaded doctor's Kyber secret key & sensor's Dilithium public key.\n")

    # 2) Fetch documents from MongoDB (most recent first)
    #    You can adjust the query or sorting as needed
    documents = collection.find().sort("timestamp", -1).limit(5)

    for doc in documents:
        print(f"\n--- Document ID: {doc['_id']} ---")
        decrypted_data = verify_and_decrypt(doc, doc_secret_key, sensor_pub_key)

        if decrypted_data is None:
            # Signature or decryption failed
            continue

        print("Decrypted Sensor Data:", decrypted_data)

        # 3) Check for anomalies
        anomalies = check_anomaly(decrypted_data)
        if anomalies:
            print("Anomalies Detected:", anomalies)
            # Here you could send an alert to the patient/family
        else:
            print("No anomalies detected.")

if __name__ == "__main__":
    main()
